# 基础

## 常见问题

### 新建的Consumer从哪儿开始消费消息？

1. 如果topic在3天内发送过消息，consumer将会从保存在server里的最新消息。
2. 如果topic没有在3天内发送消息，consumer将会从server的尾端开始消费消息。
3. 如果消费者是重启的状态，则会从上次消费的位置开始消费消息。
4. 可以自定义消费的模式，如CONSUMER_FROM_LAST_OFFSET将会从最新的消息开始消费,如果是CONSUME_FROM_FIRST_OFFSET则会消费存在在BROKER中的所有消息，也可以定义CONSUMMER_FROM_TIMESTAMP按自定义时间开始消费。

### 当消费失败时，是如何重新消费消息的？

1. 如果是在集群模式，消费者的业务逻辑代码将会返回NULL,Action,ReconsumerLaater或者抛出异常。然后继续重复尝试16次消费动作，如果还未被正确消费该消息将会被抛弃。
2. 如果是广播模式，仍然会保证消息至少会被消费一次，但是 no resend option is provided(不理解啥意思)

### 如何查询被消费失败的消息(用的少所以不理解)

1. 通过时间使用topic查询，将可以查询一段时间内的消息。
2. 使用Topic和消息id精确查询消息
3. 或者使用Topic和message key精确查询某一类拥有相同message key的消息。

### 如何保证消息只被传递一次

RocketMQ只能确保所有消息不止被传递一次，在大多数情况下消息是不会重复的。

### 默认的配置问题

一般消息都只会存3天，其中未使用超过三天的消息将会被删除(这样说使用和未使用有啥区别呢？)。还有就是message Body一般长度就256KB。

### 消息一致性

从消息的传递流程来看，producer->master broker->slave broker->consumer。首先为了保证消息确实传递成功，在不同进程间肯定有相应应答机制保证。对于producer->master和slave->consumer，通过应答保证至少有一次成功。master自身可以通过同步刷盘保证消息正确持久化，也可以通过同步从节点保证可用性，但官网建议使用主从而不是同步刷盘，是因为同步刷盘代价更高(同步双写可以保证完全避免单点故障)？(如果接收到了SEND_OK，则表示接收成功，但如果失败则会按如下逻辑抛出异常。如果在同步刷盘模式下，在5秒内刷盘失败会得到FLUSH\_DISK\_TIMEOUT的异常。同理，在同步主从的模式下，5秒内同步失败，会有FLUSHS\_SLAVE\_TIMEOUT异常。如果主节点配置的是同步主从模式，而没有配置从节点或无从节点可用时，会产生SLAVE\_NOT\_AVAILABLE的异常。)对于broker崩溃的同时，出现timeout(同步的，而不是发送的)异常，可能需要重新发送消息以保证消息确实发送成功，此时需要保证幂等性避免重复消费。

## 消息过滤

rocketmq的过滤通过tag来实现，其中这部分内容由broker承担，主要是为了减少网络传播，但这样会增加broker的负担。

## 回溯消费

rocketmq提供按毫秒级的维度回复。

## 重复消息出现的情况
